pivotline = which.min(coltmp)
data[pivotline,] <- data[pivotline,] / data[pivotline,pivotcolomn]
n <- 1
while (n < ncol(data)-1-stop)
{
if(n==pivotline)
{
n <- n+1
}
else
{
data[n, ] <- data[n, ] - data[pivotline, ] * data[n,pivotcolomn]
n <- n+1
}
}
pivotcolomn = which.min(data[nrow(data),1:(ncol(data)-1)])
count <- count + 1
}
return(data)
}
Phase2 <- function(data,line_to_add){
n <- nrow(data)
m <- ncol(data)
count=0
for(i in (1:m))
{
if(data[n,i]==1)
{
count=count+1
}
}
temp_data <- data[1:(n-1),1:m]
temp_data <- rbind(temp_data,line_to_add)
Z <- temp_data[1:n,m]
data <- data[1:(n-1),1:(m-count-1)]
data <- rbind(data,line_to_add[,1:(ncol(line_to_add)-count-1)])
data <- cbind(data,Z)
data[n,]=-data[n,]
return(data)
}
End <- function(data,max){
l=nrow(data)
for (i in (1:ncol(max)))
{
c=i
if((data[l,c]!=(-max[i])))
{
for(j in (1:(l-1)))
{
if(data[j,c]==1)
{
pivotline = j
}
}
x=(max[c]-data[l,c])/data[pivotline,c]
for(j in (1:ncol(data)))
{
data[l,j]=data[l,j]+x*data[pivotline,j]
}
}
}
return(data)
}
#Function to use Simplex or 2-Phase Simplex
Simplexs <- function(data){
max = data[nrow(data),1:(ncol(data)-2)]
#Transform and Add Slacks
data_transformed = slacks(data)
test <- FALSE
i=1
while(i<nrow(data_transformed) & test == FALSE){
if(data_transformed[nrow(data_transformed)-i,ncol(data_transformed)-i]==-1)
{
test = TRUE
}
i=i+1
}
if(test == TRUE)
{
#2-Phase Simplex
return(Two_Phase_Simplex(data_transformed,max))
}
else
{
#Simplex
return(Simplex(data_transformed))
}
}
data = print(data)
source("C:/Users/mbmaj/OneDrive/Documents/S8/UE – ITF FUNDAMENTALS II/Numerical Optimization Methods/ST2NOM-PRJ-3/2-Phase Simplex.R")
#import functions from scripts
source("C:/Users/mbmaj/OneDrive/Documents/S8/UE – ITF FUNDAMENTALS II/Numerical Optimization Methods/ST2NOM-PRJ-3/Slacks.R", local = TRUE)
source("C:/Users/mbmaj/OneDrive/Documents/S8/UE – ITF FUNDAMENTALS II/Numerical Optimization Methods/ST2NOM-PRJ-3/Simplex.R", local = TRUE)
source("C:/Users/mbmaj/OneDrive/Documents/S8/UE – ITF FUNDAMENTALS II/Numerical Optimization Methods/ST2NOM-PRJ-3/2-Phase Simplex.R", local = TRUE)
source('~/S8/UE – ITF FUNDAMENTALS II/Numerical Optimization Methods/ST2NOM-PRJ-3/2-Phase Simplex.R', encoding = 'UTF-8')
source("C:/Users/mbmaj/OneDrive/Documents/S8/UE – ITF FUNDAMENTALS II/Numerical Optimization Methods/ST2NOM-PRJ-3/2-Phase Simplex.R", local = TRUE)
getwd()
setwd(C:/Users/mbmaj/OneDrive/Documents/S8/UE – ITF FUNDAMENTALS II/Numerical Optimization Methods/ST2NOM-PRJ-3)
setwd("C:/Users/mbmaj/OneDrive/Documents/S8/UE – ITF FUNDAMENTALS II/Numerical Optimization Methods/ST2NOM-PRJ-3")
source("./Cut.R")
#import functions from scripts
source("./Slacks.R")
source("./Slacks.R")
source("./Simplex.R")
source("./2-Phase Simplex.R")
data1 <- read_excel("./LP_System.xlsx")
#data import
library("readxl")
data1 <- read_excel("./LP_System.xlsx")
data2 <- read_excel("./LP_System2.xlsx")
data3 <- read_excel("./LP_System3.xlsx")
data4 <- read_excel("./LP_System4.xlsx")
data5 <- read_excel("./LP_System5.xlsx")
data6 <- read_excel("./LP_System6.xlsx")
data7 <- read_excel("./LP_System7.xlsx")
#import functions from scripts
setwd("C:/Users/mbmaj/OneDrive/Documents/S8/UE - ITF FUNDAMENTALS II/Numerical Optimization Methods/ST2NOM-PRJ-3")
#import functions from scripts
#setwd("C:/Users/mbmaj/OneDrive/Documents/S8/UE - ITF FUNDAMENTALS II/Numerical Optimization Methods/ST2NOM-PRJ-3")
source("./Slacks.R")
source("./Simplex.R")
source("./2-Phase Simplex.R")
source("./Slacks.R")
source("./Simplex.R")
Two_Phase_Simplex <- function(data,max){
data <- Initialization(data)
data <- Phase1_Part1(data)
line_to_add <- data[nrow(data),]
data <- Phase1_Part2(data)
data <- Phase2(data,line_to_add)
data <- Simplex(data)
data <- End(data,max)
data[nrow(data),ncol(data)]=-data[nrow(data),ncol(data)]
return(data)
}
Initialization <- function(data){
n <- nrow(data)
m <- ncol(data)
V <- rbind(data.frame(data[1:(n-1),1:(m-n)]),0)
I <- data.frame(data[(m-(n-1)):(m-1)])
Z <- data.frame(data[m])
I2<-cbind(data.frame(I[0]))
for (i in 1:ncol(I)) {
if (I[i,i]==-1) {
I2<-cbind(I2,data.frame(-I[i]))
}
}
pos=nrow(I2)
for (i in 1:ncol(I2)) {
I2[pos,i]=-1
}
I<-cbind(I,I2)
for(i in 1:ncol(I)){
colnames(I)[i] <- paste("X",i)
}
data <- data.frame(V,I,Z)
return(data)
}
Phase1_Part1 <- function(data){
n=nrow(data)
m=ncol(data)
for (i in (m-(n-1)):(m-1))
{
if(data[n,i]==-1)
{
for(j in (1:n))
{
if(data[j,i]==1)
{
l=j
}
}
for (a in (1:m))
{
data[n,a]=data[n,a]+data[l,a]
}
}
}
return(data)
}
Phase1_Part2 <- function(data){
n <- nrow(data)
m <- ncol(data)
count=0
for(i in (1:(m-2)))
{
if(data[n,i]==-1)
{
count=count+1
}
}
data[n,]=-data[n,]
data <- Modified_Simplex(data,count)
return(data)
}
Modified_Simplex <- function(data,stop){
pivotcolomn = which.min(data[nrow(data),1:(ncol(data)-1)])
count = 1
while(count < stop + 1)
{
coltmp<-array()
i=1
while(i < nrow(data)+1){
if((data[i,ncol(data)]/data[i,pivotcolomn])>0)
{
coltmp[i] = data[i,ncol(data)]/data[i,pivotcolomn]
}
i=i+1
}
pivotline = which.min(coltmp)
data[pivotline,] <- data[pivotline,] / data[pivotline,pivotcolomn]
n <- 1
while (n < ncol(data)-1-stop)
{
if(n==pivotline)
{
n <- n+1
}
else
{
data[n, ] <- data[n, ] - data[pivotline, ] * data[n,pivotcolomn]
n <- n+1
}
}
pivotcolomn = which.min(data[nrow(data),1:(ncol(data)-1)])
count <- count + 1
}
return(data)
}
Phase2 <- function(data,line_to_add){
n <- nrow(data)
m <- ncol(data)
count=0
for(i in (1:m))
{
if(data[n,i]==1)
{
count=count+1
}
}
temp_data <- data[1:(n-1),1:m]
temp_data <- rbind(temp_data,line_to_add)
Z <- temp_data[1:n,m]
data <- data[1:(n-1),1:(m-count-1)]
data <- rbind(data,line_to_add[,1:(ncol(line_to_add)-count-1)])
data <- cbind(data,Z)
data[n,]=-data[n,]
return(data)
}
End <- function(data,max){
l=nrow(data)
for (i in (1:ncol(max)))
{
c=i
if((data[l,c]!=(-max[i])))
{
for(j in (1:(l-1)))
{
if(data[j,c]==1)
{
pivotline = j
}
}
x=(max[c]-data[l,c])/data[pivotline,c]
for(j in (1:ncol(data)))
{
data[l,j]=data[l,j]+x*data[pivotline,j]
}
}
}
return(data)
}
#Function to use Simplex or 2-Phase Simplex
Simplexs <- function(data){
max = data[nrow(data),1:(ncol(data)-2)]
#Transform and Add Slacks
data_transformed = slacks(data)
test <- FALSE
i=1
while(i<nrow(data_transformed) & test == FALSE){
if(data_transformed[nrow(data_transformed)-i,ncol(data_transformed)-i]==-1)
{
test = TRUE
}
i=i+1
}
if(test == TRUE)
{
#2-Phase Simplex
return(Two_Phase_Simplex(data_transformed,max))
}
else
{
#Simplex
return(Simplex(data_transformed))
}
}
getwd()
source("./2-Phase Simplex.R")
source("./Split.R")
source("./Slacks.R")
source("./Simplex.R")
source("./2-Phase Simplex.R")
#Script for Split function
Split <- function(data){
#Information to keep
constraints=data[1:(nrow(data)-1),]
objective_function=data[nrow(data),]
nb_variables=ncol(data)-2
#Slacks + Simplex
data_calculated=Simplexs(data)
if(data_calculated[nrow(data_calculated),ncol(data_calculated)]%%1==0)
{
return(data_calculated)
}
#Split every information in two to add the two new constraints
constraints1=constraints
constraints2=constraints
data_calculated1=data_calculated
data_calculated2=data_calculated
#Add the constraints for each variable
line1=objective_function
line2=objective_function
#while(optimum%%1!=0) #Do as follow until the max is an integral
for(k in 1:nb_variables)
{
line1[k]=0
line2[k]=0
}
line1[ncol(objective_function)-1]='infeq'
line2[ncol(objective_function)-1]='supeq'
line1[2]=1
line2[2]=1
for(m in 1:nrow(data_calculated1))
{
if(data_calculated1[m,2]==1)
{
line1[ncol(line1)]=floor(data_calculated1[m,ncol(data_calculated1)])
line2[ncol(line2)]=floor(data_calculated2[m,ncol(data_calculated2)]+1)
}
}
#New constraints
constraints1=rbind(constraints1,line1)
constraints2=rbind(constraints2,line2)
#Data with new constraint
data_split1=rbind(constraints1,objective_function)
data_split2=rbind(constraints2,objective_function)
#Simplex
data_calculated1=Simplexs(data_split1)
data_calculated2=Simplexs(data_split2)
#If data_calculated optimum is integral, return result
if((data_calculated1[nrow(data_calculated1),ncol(data_calculated1)]%%1==0) && (data_calculated2[nrow(data_calculated2),ncol(data_calculated2)]%%1==0))
{
if(data_calculated1[nrow(data_calculated1),ncol(data_calculated1)]>=data_calculated2[nrow(data_calculated2),ncol(data_calculated2)])
{
return(data_calculated1)
}
else
{
return(data_calculated2)
}
}
else if(data_calculated1[nrow(data_calculated1),ncol(data_calculated1)]%%1==0)
{
return(data_calculated1)
}
else if(data_calculated2[nrow(data_calculated2),ncol(data_calculated2)]%%1==0)
{
return(data_calculated2)
}
#Take constraint from the higher optimum
if(data_calculated1[nrow(data_calculated1),ncol(data_calculated1)]>=data_calculated2[nrow(data_calculated2),ncol(data_calculated2)])
{
constraints1=constraints1
constraints2=constraints1
}
else
{
constraints1=constraints2
constraints2=constraints2
}
return(data_calculated1)
#end of while
}
source("./Split.R")
source("./Cut.R")
source("./Slacks.R")
#script for cut function
Cut <- function(data){
#Transform and Add Slacks
data_transformed = slacks(data)
return(data)
}
source("./Cut.R")
source("./IntToBin.R")
source("./Binary.R")
source("./Integral.R")
#data import
library("readxl")
data1 <- read_excel("./LP_System.xlsx")
data2 <- read_excel("./LP_System2.xlsx")
data3 <- read_excel("./LP_System3.xlsx")
data4 <- read_excel("./LP_System4.xlsx")
data5 <- read_excel("./LP_System5.xlsx")
data6 <- read_excel("./LP_System6.xlsx")
data7 <- read_excel("./LP_System7.xlsx")
main <- function(data){
print("SOLVER")
print("1. Full")
print("2. Integral")
print("3. Binary")
choice <- readline(prompt="Your choice is : ")
if (choice == 1)
{
Simplexs(data)
}
else if(choice == 2)
{
#Integral
if(check_boundaries(data))
{
data <- IntToBin(data)
print(data)
return(Binary(data))
}
else
{
#Method
print("METHOD")
print("1. Split")
print("2. Cutting Planes")
choice <- readline(prompt="Your choice is : ")
if(choice == 1)
{
#Split
return(Split(data))
}
else if (choice == 2)
{
#Cutting Planes
return(Cut(data))
}
else
{
print("Error: Wrong number.")
}
}
}
else if(choice == 3)
{
#Binary
return(Binary(data))
}
else
{
print("Error: Wrong number.")
}
}
data <- print(data)
{
print("Error: Wrong number.")
}
main(data2)
#import functions from scripts
source("./Slacks.R")
source("./Simplex.R")
source("./2-Phase Simplex.R")
source("./Split.R")
source("./Cut.R")
source("./IntToBin.R")
source("./Binary.R")
#data import
library("readxl")
data1 <- read_excel("./LP_System.xlsx")
View(data1)
data2 <- read_excel("./LP_System2.xlsx")
View(data2)
main <- function(data){
print("SOLVER\n")
print("1. Full")
print("2. Integral")
print("3. Binary")
choice <- readline(prompt="Your choice is : ")
if (choice == 1){
max = data[nrow(data),1:(ncol(data)-2)]
print(max)
#Transform and Add Slacks
data_transformed = slacks(data)
test <- FALSE
i=1
while(i<nrow(data_transformed) & test == FALSE){
if(data_transformed[nrow(data_transformed)-i,ncol(data_transformed)-i]==-1)
{
test = TRUE
}
i=i+1
}
if(test == TRUE)
{
#2-Phase Simplex
return(Two_Phase_Simplex(data_transformed,max))
}
else
{
#Simplex
return(Simplex(data_transformed))
}
}
}
main(data1)
main(data2)
main(data1)
